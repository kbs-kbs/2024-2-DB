## 관계 대수
- 관계형 데이터 모델의 연산입니다.
- 릴레이션 간의 연산이며 연산 결과는 릴레이션입니다.
- 연산자를 통한 관계 연산을 의미합니다.

> [!NOTE]
> **대수(代數)**: 수 대신 기호를 사용함   

### 관계 대수 연산의 종류
1. **[셀렉트(select)](#1-셀렉트select)**: 특정 튜플을 추출
2. **[프로젝트(project)](#2-프로젝트project)**: 특정 속성을 추출
3. **[합집합(union)](#3-합집합union)**: 릴레이션을 튜플 집합으로 간주하여 합집합을 추출
4. **[교집합(intersection)](#4-교집합intersection)**: 릴레이션을 튜플 집합으로 간주하여 교집합을 추출
5. **[차집합(difference)](#5-차집합difference)**: 릴레이션을 튜플 집합으로 간주하여 차집합을 추출
6. **[카티션 프로덕트(cartesian product)](#6-카티션프로덕트cartesianproduct)**: 릴레이션을 튜플 집합으로 간주하여 곱집합을 추출
7. **[조인(join)](#7-조인join)**: 두 릴레이션을 결합
8. **[디비전(division)](#8-디비전division)**: 두 릴레이션을 분리

> [!NOTE]
> **카티션 또는 카테시안(cartesian)**: 철학자이자 수학자인 데카르트(Descartes)의 라틴어 표기인 카르테시우스(Cartesius)에서 유래한 단어인 카티션은 "데카르트의", "데카르트적"이라는 뜻을 가지고 있습니다.

### 관계 대수의 분류 방법 2
1. **릴레이션을 집합으로 보는가?**
   - **집합 연산**:
     - 합집합
     - 교집합
     - 차집합
     - 카티션 프로덕트   
   - **순수 관계 연산**:
     - 셀렉트
     - 프로젝트
     - 조인
     - 디비전
3. **다른 연산으로 대체할 수 없는가?**
   - **기본 연산**:
     - 셀렉트
     - 프로젝트
     - 합집합
     - 차집합
     - 카티션 프로덕트
   - **복합 연산**:
     - 교집합
     - 조인
     - 디비전


### 1. 셀렉트(select)
- 선택 조건식을 만족하는 튜플을 추출합니다.

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`\sigma_{성별={'}남{'}}{(학생)}`$|동일|조건식을 만족하는 튜플의 개수|

```sql
select * from 학생
where 성별='남';
```

### 2. 프로젝트(project)
- 속성 리스트에 나열된 속성을 추출합니다.

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`\Pi_{이름,\,성별,\,학년}{(학생)}`$|리스트에 포함된 속성의 개수|동일|

```sql
select 이름, 성별, 학년 from 학생;
```

### 3. 합집합(union)
- 릴레이션을 튜플 집합으로 간주하여 합집합을 추출합니다.

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{학생1}\cup{학생2}`$|동일|두 카디널리티의 합 - 중복된 튜플의 수|

```sql
select 이름, 성별, 학년 from 학생1
union
select 이름, 성별, 학년 from 학생2;
```


### 4. 교집합(intersection)
- 릴레이션을 튜플 집합으로 간주하여 교집합을 추출합니다.

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{학생1}\cap{학생2}`$|동일|중복된 튜플의 수|

```sql
select 이름, 성별, 학년 from 학생1
intersect
select 이름, 성별, 학년 from 학생2;
```

### 5. 차집합(difference)
- 릴레이션을 튜플 집합으로 간주하여 차집합을 추출합니다.

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{학생1}-{학생2}`$|동일|학생1의 카디널리티 - 중복된 튜플의 수|

```sql
select 이름, 성별, 학년 from 학생1
except
select 이름, 성별, 학년 from 학생2;
```

### 6. 카티션 프로덕트(cartesian product)
- 릴레이션을 튜플 집합으로 간주하여 곱집합을 추출합니다.

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{학생1}\times{학생2}`$|각 차수의 합|각 카디널리티의 곱|

```sql
select * from 학생1, 학생2;
```

### 7. 조인(join)
- 두 릴레이션을 결합합니다.
  
**세타 조인**:
- 비교 연산자 사용

**동등 조인**:
- '=' 연산자 사용

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{학생}\bowtie_{(학생.학번,\,수강.학번)}{수강}`$|학생1의 차수|학생1의 만족 튜플 개수|

아래는 세타 조인이자 동등 조인의 DML 예시입니다.

```sql
select 학생1.이름, 학생1.성별, 학생2.학년 from 학생1
join 학생2 on 학생1.학번 = 학생2.학번;
```

**자연 조인**

```
조인_조건식 = R1.학번 = R2.학번

R1 JOIN n(조인_조건식) R2
```

```sql
select * from 학생1
natural join 학생2;
```

### 8. 디비전(division)
두 릴레이션을 분리합니다.

특정 값을 모두 가지고 있는 튜플을 찾는 연산

조건: R2 속성은 R1 속성의 부분 집합

튜플의 차집합

1. R2의 튜플을 포함하는 R1의 튜플을 찾고
2. 거기서 R2를 뺌


|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{학생1}\div{학생2}`$|학생1의 차수 - 학생2의 차수||

```sql
select 학생.이름 from 학생
WHERE NOT EXISTS (
    SELECT * FROM 과목
    WHERE NOT EXISTS (
        SELECT *
        FROM 수강
        WHERE 수강.학생ID = 학생.학생ID
        AND 수강.과목ID = 과목.과목ID
    )
);
```

### 확장 연산

### 세미 조인
**왼쪽 세미 조인**:
- 자연 조인 결과 중 왼쪽 릴레이션의 속성만 반환

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{학생}\ltimes_{(학생.학번,\,수강.학번)}{수강}`$|학생의 차수|조인 조건을 만족하는 학생 튜플의 개수|

```sql
select * from 학생
where 학번 in (select 학번 from 수강)
```

**오른쪽 세미 조인**:
- 자연 조인 결과 중 오른쪽 릴레이션의 속성만 반환

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{학생}\rtimes_{(학생.학번,\,수강.학번)}{수강}`$|수강의 차수|조인 조건을 만족하는 수강 튜플의 개수|

```sql
select * from 수강
where 학번 in (select 학번 from 학생)
```

> [!NOTE]
> 세미 조인에서는 `join` 키워드를 사용하지 않습니다.

### 외부 조인
- 없는 값도 null로 포함

**왼쪽 외부 조인**:
- 왼쪽 릴레이션 중 오른쪽 릴레이션에 없던 속성은 'null'로 표시 후 반환

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{직원}⟕_{(직원.부서ID,\,부서.부서ID)}{부서}`$|차수의 합 - 1|직원의 카디널리티|

```sql
select * from 직원
left outer join 부서 on 직원.부서ID = 부서.부서ID;
```

**오른쪽 외부 조인**:
- 오른쪽 릴레이션 중 왼쪽 릴레이션에 없던 속성은 'null'로 표시 후 반환

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{직원}⟖_{(직원.부서ID,\,부서.부서ID)}{부서}`$|차수의 합 - 1|부서의 카디널리티|

```sql
select * from 직원
right outer join 부서 on 직원.부서ID = 부서.부서ID;
```

**완전 외부 조인**:

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{직원}⟗_{(직원.부서ID,\,부서.부서ID)}{부서}`$|차수의 합 - 1|카디널리티의 합 - 조인 조건을 만족하는 튜플의 개수|

```sql
select * from 직원
full outer join 부서 on 직원.부서ID = 부서.부서ID;
```

### 외부 합집합

|관계 대수식|결과 차수|결과 카디널리티|
|---|---|---|
|$`{직원}\cup^+{부서}`$|차수의 합 - 중복 속성의 개수|카디널리티의 합 - 중복 튜플의 개수|


## 질의 트리

- 생성된 질의문을 DBMS에서 최적화하기 위해 질의 트리로 변환
- 질의 실행 계획을 결정
- 연산 순서를 조정하여 중간 단계의 릴레이션의 크기를 줄이는 것.

### 질의 트리 최적화 규칙 6
1. AND 연산자로 연결된 셀렉트 연산은 분리하여 개별 셀렉트 연산으로 변환
2. 셀렉트 연산 질의 트리 아래쪽으로 이동
3. 프로젝트 연산도 분리해서 질의 트리 아래쪽으로 이동
4. 여러 셀렉트 연산중에서는 결과 릴레이션 크기가 가장 작은 것부터 제한적 셀렉트 연산 
순으로 질의 트리 최하단으로 이동
5. 카티션 프로덕트 연산과 바로 위의 셀렉트 연산은 하나의 조인 연산으로 통합 변환
6. OR 연산자로 연결된 조건식은 가능하면 AND 연산자로 연결된 조건식으로 변환
